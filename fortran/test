! ... (上面的代码是 Pass 2 填充 index_numrs) ...

       ninit=(length+1)/2

       ! --- v3-Final OMP: 每原子私有列表 (使用 maxneigh_peratom) ---
       
       ! 定义每个原子的最大邻居数 (您可以将其设为参数)
       ! !! 警告: 如果任何原子的邻居数超过此值，代码将出错 !!
       integer(kind=intype), parameter :: MAX_NEIGH_PER_ATOM = 256
       
       ! 为每个原子的私有列表分配内存
       ! 内存占用 O(numatom * MAX_NEIGH_PER_ATOM)
       allocate(local_atomindex(2, MAX_NEIGH_PER_ATOM, numatom))
       allocate(local_shifts(3, MAX_NEIGH_PER_ATOM, numatom))
       allocate(local_scutnum(numatom))
       local_scutnum = 0
       scutnum = 0

       !$OMP PARALLEL DO PRIVATE(iatom, sca, boundary, i, i1, i2, i3, j, l, tmp1, tmp) &
       !$OMP SHARED(numatom, coor, dier, ninit, imageatom, rangebox, interaction, &
       !$OMP index_rs, index_numrs, rcsq, shiftvalue, &
       !$OMP local_scutnum, local_atomindex, local_shifts, MAX_NEIGH_PER_ATOM)
       do iatom = 1, numatom
         sca=ceiling(coor(:,iatom)/dier)
  
         imageatom(:,iatom,ninit)=100d0 
         do i=1,3
           boundary(1,i)=max(1,sca(i)-interaction)
           boundary(2,i)=min(rangebox(i),sca(i)+interaction)
         end do
         do i3=boundary(1,3),boundary(2,3)
           do i2=boundary(1,2),boundary(2,2)
             do i1=boundary(1,1),boundary(2,1)
      
                 do i=1,index_rs(i1,i2,i3)
                 j=index_numrs(1,i,i1,i2,i3)
                 l=index_numrs(2,i,i1,i2,i3)
                 tmp1=imageatom(:,j,l)-coor(:,iatom)
                 tmp=dot_product(tmp1,tmp1)
                 if(tmp<=rcsq .and. tmp>0.0001) then
                   ! v3-Final OMP: 写入到 iatom 的私有列表 (无锁)
                   local_scutnum(iatom) = local_scutnum(iatom) + 1
                   
                   ! !! 关键检查 !! 
                   ! 检查是否超过了为该原子分配的内存
                   if (local_scutnum(iatom) <= MAX_NEIGH_PER_ATOM) then
                       local_atomindex(:, local_scutnum(iatom), iatom) = [iatom-1, j-1]
                       local_shifts(:, local_scutnum(iatom), iatom) = shiftvalue(:,l)
                   else
                       ! 错误：单个原子的邻居列表溢出
                       ! 在 OpenMP 循环中很难安全地停止，
                       ! 最好是在循环外的串行合并部分处理这个问题
                       ! 我们可以通过将计数器设置回一个标志值来标记错误
                       local_scutnum(iatom) = -1 ! 标记错误
                   end if
                 end if
               end do
        
             end do
           end do
         end do
         imageatom(:,iatom,ninit)=coor(:,iatom)
       end do
       !$OMP END PARALLEL DO

       ! --- v3-Final OMP: 串行合并 (拼接) ---
       do iatom = 1, numatom
         if (local_scutnum(iatom) > 0) then
           thread_start_idx = scutnum + 1
           scutnum = scutnum + local_scutnum(iatom)
           
           ! 检查总列表是否溢出
           if (scutnum > maxneigh) then
             print *, "ERROR: Total neighbor list overflow. Increase maxneigh."
             goto 999 
           end if
           
           atomindex(:, thread_start_idx : scutnum) = &
               local_atomindex(:, 1 : local_scutnum(iatom), iatom)
           shifts(:, thread_start_idx : scutnum) = &
               local_shifts(:, 1 : local_scutnum(iatom), iatom)
         
         else if (local_scutnum(iatom) == -1) then
           ! 处理单个原子溢出的错误
           print *, "ERROR: Per-atom neighbor list overflow for atom ", iatom
           print *, "Increase MAX_NEIGH_PER_ATOM."
           goto 999
         end if
       end do
 999   continue 

       deallocate(local_atomindex)
       deallocate(local_shifts)
       deallocate(local_scutnum)
       ! --------------------

       deallocate(index_numrs)
       deallocate(index_rs)
       atomindex(:,scutnum+1:maxneigh)=0
       shifts(:, scutnum+1:maxneigh)=0.0
     return
end subroutine get_neigh
